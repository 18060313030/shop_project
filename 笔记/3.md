## 三级分类导航组件使用
    三级分类导航,因为在除了home页面之外，其他引用了三级分类导航的组件，都需要动态的显示与隐藏三级分类导航
      所以需要判断一下，if(this.$route.name !== 'home'){ /*进行操作*/ }

    每次切换到三级分类导航数据所在页面，都需要重新发起请求获取数据，性能不好
      优化：将获取三级分类数据的代码放置到App.vue根组件的mounted中,这样整个运行周期只执行一次

## 搜索商品跳转路由的注意事项
    跳转路由时，会刷新掉query或params参数,但是这些参数是不能少的，需要将他们进行合并
        比如：我在search页面搜索【华为手机】，此时【手机类别】对应的参数不能少,同时还要累加上搜索关键字：keyword=手机
              情况1：先用搜索框搜索，然后再点击三级分类
              情况2：先点击三级分类，然后再搜索框搜索

## 使用mockjs假数据
    1 下载包 npm i mockjs 
    2 创建文件夹mock、创建文件mockServe.js、创建json数据文件
    3 main.js入口文件引入mockServe.js
    4 封装的axiosApi,之前的是真实服务器的,需要再添加mock的。
    5 将图片放置到public下对应位置
    6 配置vuex，actions发送异步请求,mutations修改state的数据
    7 在对应的组件上使用vuex的api调用对应的actions，mutations，state


## 轮播图---使用swiper插件
      1 npm i swiper@5 下载5版本的，6版本会有问题
      2 导入包
      3 在入口文件中引入样式 import "swiper/css/swiper.css";
      4 在组件中，添加对应的结构，js代码
      5 注意点：
        因为轮播图数据是异步获取的,直接在mounted写轮播js代码,此时会因为页面结构还未完全加载完毕,导致轮播图代码无法正常使用
        
        1）最完美的解决方案，解决轮播图问题
            Watch+nextTick：数据监听：监听已有数据变化
            $nextTick：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。
            $nextTick：可以保证页面中的结构一定是有的，经常和很多插件一起使用【部分插件的使用需要DOM结构已经存在】

## 电梯导航组件的轮播图---使用swiper插件
    1 配置api
    2 配置vuex, actions、mutations、state
        state数据的初始值数据类型，要根据接口返回的数据来创建，不能随意
    3 在根组件处，循环渲染电梯导航组件
        数据格式是 [{...},{...}]每一个对象就是一个电梯导航的数据
    4 将数据传递给子组件
    5 配置电梯导航组件的内容
        电梯导航轮播图注意点
          在首页轮播图上配置时需要watch + nextTick() 组合式使用，但是在电梯导航中不需要,直接写在mounted中即可，为啥？
          这里的数据是在根组件上请求获取的,然后在根组件页面将生成的数据通过组件传值，传递了过来
          也就是说对应的结构早就有了。此时自然可以通过代码绑定到对应的Dom元素上

## 将轮播图封装为一个组件
    因为这三个轮播图都有共同的特点，可以直接封装到一个全局组件中
    1 在component下新建carouselList文件夹和对应的文件
    2 将该文件在main.js入口文件中注册为全局组件
    3 因为是封装，要保持代码一致，所以上面电梯导航轮播图直接在mounted中书写的代码，改为和最开始那个轮播图一样的写法
      使用 watch + nextTick 书写 【watch可以保证数据是获取到的，nextTick可以保证所需的页面结构是完整的】
    4 在对应组件中导入轮播图组件，给轮播图组件传递数据

## 总结
    1 优化三级分类导航数据获取造成的性能问题
    2 跳转到搜索页面时，需要注意参数的拼接，否则会丢失参数
    3 使用mock假数据，配置轮播图数据获取的api
    4 制作轮播图(注意其中的注意点)
    5 封装轮播图全局组件