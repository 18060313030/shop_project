# 商品详情页
## 初始化配置
    1 配置静态组件
    2 设置路由信息
    3 需要传递params参数【id】给商品详情页，才能渲染对应的信息
    4 点击对应的商品，跳转对应的商品详情页。
      此时有一个bug，跳转到对应的详情页时，滚动条不会回复到顶部，依然停留再我们当前点击的位置
      使用路由的【滚动行为】
      const router = new VueRouter({
        routes,
        scrollBehavior(to, from, savedPosition) {
          return { y: 0 };
        },
      });
## 配置放大镜及轮播图效果
### 获取数据
    1 配置axios api
    2 vuex设置
    3 实例组件上通过this.$store.dispatch("xxx/xxxx",id)，与vuex的actions进行对话，actions中发送请求
    4 获取到的数据过于复杂，通过getters进行拆分
    5 通过mapGetter获取到对应的数据
### 渲染放大镜的图片信息
    放大镜以及放大镜正下方的轮播图都已经拆分成组件出去了
    需要通过父传子，然后再对应的组件上渲染图片
    渲染图片信息时可能会报错，该报错不影响程序运行，但是得懂原因。看下方的【注意点】
### 渲染商品属性页面的数据
    渲染信息时可能会报错，该报错不影响程序运行，但是得懂原因。看下方的【注意点】
### 商品属性点击时的排他思想
    点击事件传入两个参数，一个是当前点击的按钮对象信息，另一个则是整个数组
    然后遍历数组，isChecked设为0
    将当前点击的按钮对象信息的isChecked设为1
    active类名就是根据这个isChecked来动态的添加的

### 放大镜图片正下方的轮播图效果 ImageList.vue
    【使用轮播图时一定要先导入轮播图的库 swiper.js】
    修改轮播图提供的js代码，下面是部分配置
            slidesPerView: 3, // 轮播图同时显示几张图片
            slidesPreGroup: 1, // 切换轮播图时，一次切换几张
    点击轮播图按钮，修改样式，将修改的索引传递给放大镜组件，
    放大镜组件根据该索引修改对应的图片信息
      定义一个数据curIndex，当前的curIndex如果等于图片的索引，这个图片就动态添加对应的类名
      然后绑定一个点击事件，事件会修改curIndex为当前点中的图片的索引，然后同时将该索引传递给放大镜组件
      放大镜组件同样定义一个curIndex数据
          data() {
            return {
              curIndex: 0,
            }
          },
          mounted() {
            this.$bus.$on('getIndex', (index) => {
              this.curIndex = index
            })
          },
          computed: {
            // 重点位置 视频：D:\前端\学习资料\尚品会项目资料\尚硅谷大型Vue项目实战-尚品汇\尚品汇：前台项目（上）
            // 63集 21分钟
            imageList() {
              return this.skuImageList[this.curIndex] || {}
            },
          },

### 放大镜效果
    制作放大镜效果



### 注意点
  数据渲染时会有一些报错，虽然这些报错不会影响程序的正常允许，但是需要知道原因所在。
  因为初始数据是空的。我们通过点语法，获取对应数据对象中的某些属性，这些属性也是不存在的，所以会报错
  D:\前端\学习资料\尚品会项目资料\尚硅谷大型Vue项目实战-尚品汇\尚品汇：前台项目（上） 63集重点关注一下

## 商品部分
### 计算商品的数量
    商品数量只能是大于0的正整数
    将用户输入的数量乘以1可以得到对应的数字类型的数据，如果是非法数值就会转为NaN
    然后进行判断 if(isNaN() || num < 1){}
    但是用户输入了浮点数是可以通过的，所以需要将最终的结果使用parseInt处理之后，再赋值给data数据
  
### 添加购物车
    1 先配置对应的添加购物车的api
    2 vuex上actions中声明发送请求的函+数。服务器返回的消息中，没有实际数据，只有添加购物车成功与失败的消息，所以无需配置state状态
    3 组件中点击按钮，通过dispatch 与actions对话，发送对应的请求
        请求成功----路由跳转
        请求失败----告知用户
      【重点啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊】
      问题来了，我们并没有在state中保存服务器返回的结果，那么如何知道购物车究竟添加成功没有呢？
      我们在actions的函数中用了【async修饰了函数】,使其变成异步的，【return返回的结果一定是一个promise】。
      那么我可以使用await接收对应的结果，promise状态此时 要么失败要么成功
      // 将商品数据 添加或更新 到购物车
      async addOrUpdateShopCar() {
        try {
          // 需要两个参数，一个是商品id，一个是商品数量
          const res = await this.$store.dispatch('detail/addOrUpdateShopCart', {id: parseInt(this.$route.params.id), skuNum: this.skuNum})
          // 添加购物车成功，路由跳转
          this.$router.push({name:"addcartsuccess"})
          // 查看第四步
        } catch (err) {
          // 添加购物车失败
          alert(err)
        }
      },
      
      需要在vuex actions对应的函数中添加一个return返回值
        ....
        if (res.code === 200) {
          return "ok";
        } else {
          return Promise.reject("添加商品失败");
        }
      
    4 跳转路由时需要传入参数给下一个页面
      目前有个问题，传入的参数是【存放商品信息的对象】和【商品数量】
      我们直接传递对象不管是 通过query还是params 传递的都是字符串，而且还很难看
      此时我们可以将参数分为两块
        一块是【商品数量】 通过query传递即可
        一块是【存放商品信息的对象】使用sessionStorage本地会话存储存储。不是本地持久化存储。
        因为我们只需要查看此时的【商品添加购物车成功的页面】信息(不是购物车界面！！！)，无需持久化存储

### 商品添加购物车成功的提示页面
  1 通过生命周期函数接收上一个商品详情页面传递过来的数据
  2 修改组件，添加数据
  3 修改两个a标签为声明式导航，跳转到对应的位置
    